## Требования
1. Шаблонизация команд (tup like)
1. Возможность вызова PHONY комманд на производном интерпретаторе (just like)
1. Вотчинг из коробки (vake up build -w)
1. Вотчинг через демона (возможно через watchman)
1. Генерация графа зависимостей (через .dot файлы)
1. Документация комманд через markdown (vake help <build>)
1. Генерация шелл-скрипта для сборки (vake generate, tup like)
1. vake ref (tup like)

## Термины

### Артефакты сборки
Файлы которые генерирует сборщик.

### Правила сборки артефактов (build rules)
Команды которые генерируют артефакты исходя из входных файлов.

### Шаблон зависимостей
Шаблон по которому мы можем сгенерировать фактические зависимости для артефакта.
Что-то вроде шелловского глоббинга:

```go
fdeps := interpolateDeps("src/**/*.css", workingTree)
```

Где workingTree это файловое дерево проекта, а fdeps фактический набор файлов,
например `['src/a.css', 'src/foo/b.css']`

### files state (fs)
Все исходные файлы проекта.

### build state (State)
Состояние в котором находится система. 

В нее входит:
1. Зависимости артефактов от других файлов/артефактов и правил сборки
   - фактическая зависимость и шаблон (все состояние fs не дублируем)
1. Необходимые атрибуты всех файлов от которых зависят артефакты
1. build rules
1. Значения env-переменных
1. Все артефакты

Атрибуты файлов которые нам интересны:
1. Путь до файла относительно корня
1. mtime файла
1. hash файла

### Конфигурация сборки
Файл исчерпывающие описывающий сборку:

1. Шаблоны зависимостей
1. Правила сборки артефактов
1. Путь артефактов
1. Утилитарные команды пользователя

## Концепция
Если рассматривать билд-систему как функцию, то она имеет следующий вид:

```go
Build(State, fs) => Артефакты
```

Каждый артефакт зависит от пары (fs, deps_template):

```go
artefact := brule(fs, deps_templates)
```

## Примеры

TBE
